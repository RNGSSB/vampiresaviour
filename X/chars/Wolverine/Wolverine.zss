#ZSS language: https://github.com/ikemen-engine/Ikemen-GO/wiki/ZSS
#ZSS syntax highlighter for Notepad++: https://github.com/ikemen-engine/zss_npp
#-------------------------------------------------------------------------------
#Commenting in ZSS
#You may notice that the ";" character is now replaced with the "#" character.
#This is because ";" is now used to separate parameters in sctrls rather than a
#blank space.

#===============================================================================
# Functions
#===============================================================================
#Used to avoid repeating change state code to reference returning to state 0 or
#11 if crouching. $type is used to specify if it's standing or crouching.
#1 - crouching
#0 - standing
[Function EndState(type)]
if animTime = 0 {
	changeState{value: 11 * $type; ctrl: roundState > 1}
}

#-------------------------------------------------------------------------------
#Used to call system sounds from the screenpack
[Function SysSnd(b, s, c)]
playSnd{value: F $b, $s; channel: $c}

#-------------------------------------------------------------------------------
#Used to call sounds coming from this character
[Function CSnd(bank, sound, c)]
playSnd{value: S $bank, $sound; channel: $c}

#-------------------------------------------------------------------------------
#Used to apply palFx during EX moves
[Function EXFX(time)]
palFx{time: $time; add: 32, 16, 0; sinadd: 64, 32, 5, 3}

[Function AttackLevel0()]
mapSet{map: "attackDamage"; value: 20} #Damage on hit
mapset{map: "chipDamage"; value: 3}	#Damage on block
mapSet{map: "hitStop"; value: 11} #Amount of hitstop frames for both players
mapSet{map: "hitPriority"; value: 1} #If this value is higher than the opponents, then it will beat them out
mapSet{map: "hitStunAmount"; value: 12} #Amount of time spent in hitstun
mapSet{map: "hitFlags"; value: 0} #0 = MAF, 1 = HAF (Whiffs on crouchers), 2 = LAF (Whiffs on standing), 3 = AF (Air only), 4 = MAFD (Hits all for supers), 5 = D (Only hits hard knockdown)
mapSet{map: "guardFlags"; value: 0} #0 = MA (Blocked by everything), 1= M (Block all ground, hit in air), 2 = L (Block Low), 3 = H (Block High), 4 = HA (Block high and air for air attacks)
mapSet{map: "untechTime"; value: 14} #Amount of time before you can tech in the air
mapSet{map: "blockStunAmount"; value: 9} #amount of blockstun
mapSet{map: "hitSparkNum"; value: 0} #What hit spark to use
mapSet{map: "sparkPosX"; value: -10} #The X position
mapSet{map: "sparkPosY"; value: -76} #Y Position
mapSet{map: "attackSoundGroup"; value: 5}  #Sound on hit
mapSet{map: "attackSoundIndex"; value: 0} 
mapSet{map: "guardSoundGroup"; value: 6} #Sound on block
mapSet{map: "guardSoundIndex"; value: 0} 
mapSet{map: "groundPushbackX"; value: -4} #Velocity applied to enemy on ground hit
mapSet{map: "groundPushbackY"; value: 0}
mapSet{map: "hitSlideTime"; value: 5} #how much time the enemy slides back after getting hit
mapSet{map: "airPushbackX"; value: -1.4} #Velocity applied to enemy on air hit
mapSet{map: "airPushbackY"; value: -4}
mapSet{map: "groundGuardPushbackX"; value: -4} #Block pushback
mapSet{map: "guardSlideTime"; value: 5} #how much time the enemy slides back after blocking
mapSet{map: "airGuardPushbackX"; value: -1.9} #Air block pushback
mapSet{map: "airGuardPushbackY"; value: -0.8}
mapSet{map: "hardKnockDown"; value: 0}	#If opponent goes into hard knockdown
mapSet{map: "hardKnockDownRecover"; value: 0}
mapSet{map: "AttackKill"; value: 1} #Does the attack kill or not
mapSet{map: "GuardKill"; value: 1}	#Does chip damage kill
mapSet{map: "animationType"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "animationTypeAir"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "groundType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "airType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "directionMultiplierX"; value: 1.5}
mapSet{map: "directionMultiplierY"; value: 1.1}
mapSet{map: "gravityFreeHits"; value: 3}
mapSet{map: "screenShakeSpeed"; value: 15}

[Function AttackLevel1()]
mapSet{map: "attackDamage"; value: 25} #Damage on hit
mapset{map: "chipDamage"; value: 4}	#Damage on block
mapSet{map: "hitStop"; value: 12} #Amount of hitstop frames for both players
mapSet{map: "hitPriority"; value: 1} #If this value is higher than the opponents, then it will beat them out
mapSet{map: "hitStunAmount"; value: 14} #Amount of time spent in hitstun
mapSet{map: "hitFlags"; value: 0} #0 = MAF, 1 = HAF (Whiffs on crouchers), 2 = LAF (Whiffs on standing), 3 = AF (Air only), 4 = MAFD (Hits all for supers), 5 = D (Only hits hard knockdown)
mapSet{map: "guardFlags"; value: 0} #0 = MA (Blocked by everything), 1= M (Block all ground, hit in air), 2 = L (Block Low), 3 = H (Block High), 4 = HA (Block high and air for air attacks)
mapSet{map: "untechTime"; value: 16} #Amount of time before you can tech in the air
mapSet{map: "blockStunAmount"; value: 11} #amount of blockstun
mapSet{map: "hitSparkNum"; value: 0} #What hit spark to use
mapSet{map: "sparkPosX"; value: -10} #The X position
mapSet{map: "sparkPosY"; value: -76} #Y Position
mapSet{map: "attackSoundGroup"; value: 5}  #Sound on hit
mapSet{map: "attackSoundIndex"; value: 0} 
mapSet{map: "guardSoundGroup"; value: 6} #Sound on block
mapSet{map: "guardSoundIndex"; value: 0} 
mapSet{map: "groundPushbackX"; value: -4} #Velocity applied to enemy on ground hit
mapSet{map: "groundPushbackY"; value: 0}
mapSet{map: "hitSlideTime"; value: 5} #how much time the enemy slides back after getting hit
mapSet{map: "airPushbackX"; value: -1.4} #Velocity applied to enemy on air hit
mapSet{map: "airPushbackY"; value: -4}
mapSet{map: "groundGuardPushbackX"; value: -4} #Block pushback
mapSet{map: "guardSlideTime"; value: 5} #how much time the enemy slides back after blocking
mapSet{map: "airGuardPushbackX"; value: -1.9} #Air block pushback
mapSet{map: "airGuardPushbackY"; value: -0.8}
mapSet{map: "hardKnockDown"; value: 0}	#If opponent goes into hard knockdown
mapSet{map: "hardKnockDownRecover"; value: 0}
mapSet{map: "AttackKill"; value: 1} #Does the attack kill or not
mapSet{map: "GuardKill"; value: 1}	#Does chip damage kill
mapSet{map: "animationType"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "animationTypeAir"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "groundType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "airType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "directionMultiplierX"; value: 1.5}
mapSet{map: "directionMultiplierY"; value: 1.1}
mapSet{map: "gravityFreeHits"; value: 3}
mapSet{map: "screenShakeSpeed"; value: 15}

[Function AttackLevel2()]
mapSet{map: "attackDamage"; value: 30} #Damage on hit
mapset{map: "chipDamage"; value: 4}	#Damage on block
mapSet{map: "hitStop"; value: 13} #Amount of hitstop frames for both players
mapSet{map: "hitPriority"; value: 1} #If this value is higher than the opponents, then it will beat them out
mapSet{map: "hitStunAmount"; value: 16} #Amount of time spent in hitstun
mapSet{map: "hitFlags"; value: 0} #0 = MAF, 1 = HAF (Whiffs on crouchers), 2 = LAF (Whiffs on standing), 3 = AF (Air only), 4 = MAFD (Hits all for supers), 5 = D (Only hits hard knockdown)
mapSet{map: "guardFlags"; value: 0} #0 = MA (Blocked by everything), 1= M (Block all ground, hit in air), 2 = L (Block Low), 3 = H (Block High), 4 = HA (Block high and air for air attacks)
mapSet{map: "untechTime"; value: 18} #Amount of time before you can tech in the air
mapSet{map: "blockStunAmount"; value: 13} #amount of blockstun
mapSet{map: "hitSparkNum"; value: 0} #What hit spark to use
mapSet{map: "sparkPosX"; value: -10} #The X position
mapSet{map: "sparkPosY"; value: -76} #Y Position
mapSet{map: "attackSoundGroup"; value: 5}  #Sound on hit
mapSet{map: "attackSoundIndex"; value: 1} 
mapSet{map: "guardSoundGroup"; value: 6} #Sound on block
mapSet{map: "guardSoundIndex"; value: 1} 
mapSet{map: "groundPushbackX"; value: -4} #Velocity applied to enemy on ground hit
mapSet{map: "groundPushbackY"; value: 0}
mapSet{map: "hitSlideTime"; value: 5} #how much time the enemy slides back after getting hit
mapSet{map: "airPushbackX"; value: -1.4} #Velocity applied to enemy on air hit
mapSet{map: "airPushbackY"; value: -4}
mapSet{map: "groundGuardPushbackX"; value: -4} #Block pushback
mapSet{map: "guardSlideTime"; value: 5} #how much time the enemy slides back after blocking
mapSet{map: "airGuardPushbackX"; value: -1.9} #Air block pushback
mapSet{map: "airGuardPushbackY"; value: -0.8}
mapSet{map: "hardKnockDown"; value: 0}	#If opponent goes into hard knockdown
mapSet{map: "hardKnockDownRecover"; value: 0}
mapSet{map: "AttackKill"; value: 1} #Does the attack kill or not
mapSet{map: "GuardKill"; value: 1}	#Does chip damage kill
mapSet{map: "animationType"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "animationTypeAir"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "groundType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "airType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "directionMultiplierX"; value: 1.5}
mapSet{map: "directionMultiplierY"; value: 1.1}
mapSet{map: "gravityFreeHits"; value: 3}
mapSet{map: "screenShakeSpeed"; value: 25}

[Function AttackLevel3()]
mapSet{map: "attackDamage"; value: 40} #Damage on hit
mapset{map: "chipDamage"; value: 5}	#Damage on block
mapSet{map: "hitStop"; value: 14} #Amount of hitstop frames for both players
mapSet{map: "hitPriority"; value: 1} #If this value is higher than the opponents, then it will beat them out
mapSet{map: "hitStunAmount"; value: 19} #Amount of time spent in hitstun
mapSet{map: "hitFlags"; value: 0} #0 = MAF, 1 = HAF (Whiffs on crouchers), 2 = LAF (Whiffs on standing), 3 = AF (Air only), 4 = MAFD (Hits all for supers), 5 = D (Only hits hard knockdown)
mapSet{map: "guardFlags"; value: 0} #0 = MA (Blocked by everything), 1= M (Block all ground, hit in air), 2 = L (Block Low), 3 = H (Block High), 4 = HA (Block high and air for air attacks)
mapSet{map: "untechTime"; value: 20} #Amount of time before you can tech in the air
mapSet{map: "blockStunAmount"; value: 16} #amount of blockstun
mapSet{map: "hitSparkNum"; value: 0} #What hit spark to use
mapSet{map: "sparkPosX"; value: -10} #The X position
mapSet{map: "sparkPosY"; value: -76} #Y Position
mapSet{map: "attackSoundGroup"; value: 5}  #Sound on hit
mapSet{map: "attackSoundIndex"; value: 1} 
mapSet{map: "guardSoundGroup"; value: 6} #Sound on block
mapSet{map: "guardSoundIndex"; value: 1} 
mapSet{map: "groundPushbackX"; value: -4} #Velocity applied to enemy on ground hit
mapSet{map: "groundPushbackY"; value: 0}
mapSet{map: "hitSlideTime"; value: 5} #how much time the enemy slides back after getting hit
mapSet{map: "airPushbackX"; value: -1.4} #Velocity applied to enemy on air hit
mapSet{map: "airPushbackY"; value: -4}
mapSet{map: "groundGuardPushbackX"; value: -4} #Block pushback
mapSet{map: "guardSlideTime"; value: 5} #how much time the enemy slides back after blocking
mapSet{map: "airGuardPushbackX"; value: -1.9} #Air block pushback
mapSet{map: "airGuardPushbackY"; value: -0.8}
mapSet{map: "hardKnockDown"; value: 0}	#If opponent goes into hard knockdown
mapSet{map: "hardKnockDownRecover"; value: 0}
mapSet{map: "AttackKill"; value: 1} #Does the attack kill or not
mapSet{map: "GuardKill"; value: 1}	#Does chip damage kill
mapSet{map: "animationType"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "animationTypeAir"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "groundType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "airType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "directionMultiplierX"; value: 1.5}
mapSet{map: "directionMultiplierY"; value: 1.1}
mapSet{map: "gravityFreeHits"; value: 3}
mapSet{map: "screenShakeSpeed"; value: 25}

[Function AttackLevel4()]
mapSet{map: "attackDamage"; value: 50} #Damage on hit
mapset{map: "chipDamage"; value: 6}	#Damage on block
mapSet{map: "hitStop"; value: 15} #Amount of hitstop frames for both players
mapSet{map: "hitPriority"; value: 1} #If this value is higher than the opponents, then it will beat them out
mapSet{map: "hitStunAmount"; value: 21} #Amount of time spent in hitstun
mapSet{map: "hitFlags"; value: 0} #0 = MAF, 1 = HAF (Whiffs on crouchers), 2 = LAF (Whiffs on standing), 3 = AF (Air only), 4 = MAFD (Hits all for supers), 5 = D (Only hits hard knockdown)
mapSet{map: "guardFlags"; value: 0} #0 = MA (Blocked by everything), 1= M (Block all ground, hit in air), 2 = L (Block Low), 3 = H (Block High), 4 = HA (Block high and air for air attacks)
mapSet{map: "untechTime"; value: 22} #Amount of time before you can tech in the air
mapSet{map: "blockStunAmount"; value: 18} #amount of blockstun
mapSet{map: "hitSparkNum"; value: 0} #What hit spark to use
mapSet{map: "sparkPosX"; value: -10} #The X position
mapSet{map: "sparkPosY"; value: -76} #Y Position
mapSet{map: "attackSoundGroup"; value: 5}  #Sound on hit
mapSet{map: "attackSoundIndex"; value: 2} 
mapSet{map: "guardSoundGroup"; value: 6} #Sound on block
mapSet{map: "guardSoundIndex"; value: 2} 
mapSet{map: "groundPushbackX"; value: -4} #Velocity applied to enemy on ground hit
mapSet{map: "groundPushbackY"; value: 0}
mapSet{map: "hitSlideTime"; value: 5} #how much time the enemy slides back after getting hit
mapSet{map: "airPushbackX"; value: -1.4} #Velocity applied to enemy on air hit
mapSet{map: "airPushbackY"; value: -4}
mapSet{map: "groundGuardPushbackX"; value: -4} #Block pushback
mapSet{map: "guardSlideTime"; value: 5} #how much time the enemy slides back after blocking
mapSet{map: "airGuardPushbackX"; value: -1.9} #Air block pushback
mapSet{map: "airGuardPushbackY"; value: -0.8}
mapSet{map: "hardKnockDown"; value: 0}	#If opponent goes into hard knockdown
mapSet{map: "hardKnockDownRecover"; value: 0}
mapSet{map: "AttackKill"; value: 1} #Does the attack kill or not
mapSet{map: "GuardKill"; value: 1}	#Does chip damage kill
mapSet{map: "animationType"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "animationTypeAir"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "groundType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "airType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "directionMultiplierX"; value: 1.5}
mapSet{map: "directionMultiplierY"; value: 1.1}
mapSet{map: "gravityFreeHits"; value: 3}
mapSet{map: "screenShakeSpeed"; value: 30}

[Function Init5A()]
mapSet{map: "trainingIsALow"; value: 0}


[Function Init5B()]
mapSet{map: "trainingIsALow"; value: 0}

[Function Init5C()]
mapSet{map: "trainingIsALow"; value: 0}

[Function Init5D()]
mapSet{map: "trainingIsALow"; value: 0}

[Function Init2A()]
mapSet{map: "trainingIsALow"; value: 0}
mapSet{map: "sparkPosY"; value: -10}

[Function Init2B()]
mapSet{map: "trainingIsALow"; value: 0}
mapSet{map: "sparkPosY"; value: -10}

[Function Init2C()]
mapSet{map: "trainingIsALow"; value: 0}
mapSet{map: "sparkPosY"; value: -10}

[Function Init2D()]
mapSet{map: "trainingIsALow"; value: 0}
mapSet{map: "sparkPosY"; value: -10}

[Function InitjA()]
mapSet{map: "trainingIsALow"; value: 0}
mapSet{map: "sparkPosY"; value: -36}

[Function InitjB()]
mapSet{map: "trainingIsALow"; value: 0}
mapSet{map: "sparkPosY"; value: -36}

[Function InitjC()]
mapSet{map: "trainingIsALow"; value: 0}
mapSet{map: "sparkPosY"; value: -36}

[Function InitjD()]
mapSet{map: "trainingIsALow"; value: 0}
mapSet{map: "sparkPosY"; value: -36}

[Function JumpCancel()]
IgnoreHitPause{
if moveContact && command = "holdup"  { 
	if (stateType != A ){
		mapSet{map: "trainingIsALow"; value: 0}
		changeState{value: 40}
	}
	
	#if (Map(CDU) || command = "holdup" && Map(h_a)) && stateType != A {
	#changeState{value: 6100}
	#}

	if (statetype = A && map(airJumpCount) > 0) {
	mapSet{map: "trainingIsALow"; value: 0}
	changeState{value: 46}
	}
}
}

[Function DamageScaling(multiplier)]
if !isHelper {
	if map(comboCount) < 1{
		ignoreHitPause{
		 MapSet{map: "DamageScaling"; value: $multiplier}
		}
	}
	else if map(comboCount) > 1 && map(DamageScaling) > map(damageScalingMax) 
	{
		ignoreHitPause{
			MapAdd{map: "DamageScaling"; value: map(damageScalingPerHit)}
		}
	}
}else{
	if parent,map(comboCount) < 1{
		ignoreHitPause{
		 RootMapSet{map: "DamageScaling"; value: $multiplier}
		}
	}
	else if parent,map(comboCount) > 1 && parent,map(DamageScaling) > parent,map(damageScalingMax) {
		ignoreHitPause{
			RootMapAdd{map: "DamageScaling"; value: parent,map(damageScalingPerHit)}
		}
	}
}

[Function SetAttackLaunchSpeed(x1, y1, x2, y2)]
mapSet{map: "groundPushbackX"; value: $x1} #Velocity applied to enemy on ground hit
mapSet{map: "groundPushbackY"; value: $y1}
mapSet{map: "airPushbackX"; value: $x2} #Velocity applied to enemy on air hit
mapSet{map: "airPushbackY"; value: $y2}

[Function SetAttackLandingLag(landingFrames)]
mapSet{map:"attackLandingLag"; value: $landingFrames}
changeState{value: 107; ctrl: 0}

#===============================================================================
# Walk Override
#===============================================================================
[StateDef 20; type: S; physics: S; sprpriority: 0;]

if command = "holdback"&& !aiLevelF || aiLevelF && map(AIw) = -1 {
	velSet{x: const(velocity.walk.back.x)}
} else if command = "holdfwd" && !aiLevelF || aiLevelF && map(AIw) = 1 {
	velSet{x: const(velocity.walk.fwd.x)}
}
if vel x > 0 {
	if cond(anim = 5, animTime = 0, anim != 20) {
		changeAnim{value: 20}
	}
} else if vel x < 0 {
	if cond(anim = 5, animTime = 0, anim != 21) {
		changeAnim{value: 21}
	}
}

#===============================================================================
# Lose by Time Over
#===============================================================================
# ZSS difficulty: basic
#This is how statedefs are defined in ZSS. It must always end with a ";" or it
#will result in a crash. 
[StateDef 170;
type: S; movetype: I; physics: S;
anim: 170; ctrl: 0; 
sprpriority: 1;]

#If you used a trigger that normally read "trigger1 = 1" you can just declare
#the sctrl with no condition like below.
notHitBy{value: SCA; time: 1}

#===============================================================================
# Win state decider
#===============================================================================
# ZSS difficulty: basic
[StateDef 180;
type: S; movetype: I; physics: S;
anim: -2; ctrl: 0; 
sprpriority: 1;]

changeState{value: 181; ctrl: 0}

#===============================================================================
# win pose 1 - Bow
#===============================================================================
# ZSS difficulty: basic
[StateDef 181;
type: S; movetype: I; physics: S;
anim: 181; ctrl: 0; 
sprpriority: 1;]

#trigger is replaced with a simple "if". All conditions can be handled the same
#with multiple if blocks. Optional Assert roundnotover
if animTime < -2 {
	assertSpecial{flag: roundnotover}
}

notHitBy{value: SCA; time: 1}

#===============================================================================
# Introduction
#===============================================================================
# ZSS difficulty: basic
[StateDef 191;
type: S; movetype: I; physics: S;
anim: 190; ctrl: 0; 
sprpriority: 1;]

if roundState = 0 {
	changeAnim{value: 190}
}

#Assert this until you want "round 1, fight" to begin
assertSpecial{flag: intro}

#You can delete the following two controllers if you're building your own
#character using KFM. These are the wood pieces that KFM kicks. This is how
#persistent = 0 is applied, if this were an sctrl that has no trigger, the
#persistent(0) would be that trigger e.g. persistent(0){sctrl{}}
persistent(0) if roundState != 0 {
	explod{
		anim: 191;
		postype: p1;
		pos: 260, -90;
		velocity: -4.2, -7;
		accel: 0, .32;
		removetime: 48;
	}
}

if animElemTime(7) = 1 {
	explod{
		anim: 192;
		postype: p1;
		pos: 60, -70;
		velocity: 2, -4;
		accel: 0, .32;
		removetime: 35;
	}
}

#You can delete the following two controllers if you're building your own
#character using KFM. These play back the sounds of the wood block being broken.
if animElem = 7 {
	#It is worth mentioning that if you want to use the rest of the parameters
	#a playSnd uses, you can use it just the same as below:
	# Playsnd{value: F5, 2; channel: 1; volume: -40}
	call SysSnd(5, 2, 1);
}

if animElemTime(7) = 3 {
	call SysSnd(5, 3, 2);
}

#Change to stand state when done
call EndState(0);

#-------------------------------------------------------------------------------
[StateDef 195;
type: S; movetype: I; physics: S;
anim: 195; ctrl: 0; 
sprpriority: 2;]

if time = 40 {
	ctrlSet{value: 1}
}

#Change to stand state when done
call EndState(0);

#===============================================================================
# Stand Light Punch
#===============================================================================
# ZSS difficulty: easy
[StateDef 200;
type: S;                              #State-type: S-stand, C-crouch, A-air, L-liedown
movetype: A;                          #Move-type: A-attack, I-idle, H-gethit
physics: S;                           #Physics: S-stand, C-crouch, A-air
                            #Number of air juggle points move takes
#Commonly-used controllers:                  #Set velocity (x, y) (Def: no change)
ctrl: 0;                              #Set ctrl (Def: no change)
anim: 200;                            #Change animation (Def: no change)
poweradd: 10;                         #Power to add (Def: 0)
sprpriority: 2;]                      #Set p1's sprite layering priority to 2 (in front)

if time = 0{
	call AttackLevel0();
	call Init5A();
	mapSet{map: "attackSoundGroup"; value: 5}
	mapSet{map: "attackSoundIndex"; value: 3}
	mapSet{map: "guardSoundGroup"; value: 6}
	mapSet{map: "guardSoundIndex"; value: 3}
}

IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if animElem = 3 { 
	#When using zss sctrls, you must have the bracket on the same line as the
	#sctrl's name as specified below e.g. "HitDef{"
	hitDef{
		attr: S, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: Light;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(0.8);
		}
	}
}

if time = 1 {
	#It is worth mentioning that if you want to use the rest of the parameters
	#a playSnd uses, you can use it just the same as below:
	# Playsnd{value: S0, 0; channel: 1}
	call CSnd(0, 0, 1);
}

#Change to stand state when done
call EndState(0);

#===============================================================================
# Standing strong punch
#===============================================================================
[StateDef 210;
type: S; movetype: A; physics: S;
 poweradd: 30; ctrl: 0;
 anim: 220;
sprpriority: -1;]

if animElemTime(2) >= 0 && animElemTime(7) < 0 {
	width{value: 15, 0}
}

if time = 0{
	call AttackLevel2();
	call Init5B();
	mapSet{map: "attackSoundGroup"; value: 5}
	mapSet{map: "attackSoundIndex"; value: 4}
	mapSet{map: "guardSoundGroup"; value: 6}
	mapSet{map: "guardSoundIndex"; value: 4}
}

if time = 2 {
	#It is worth mentioning that if you want to use the rest of the parameters
	#a playSnd uses, you can use it just the same as below:
	# Playsnd{value: S0, 4; channel: 1}
	call CSnd(0, 4, 1);
}

IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if animElem = 3 {
	hitDef{
		attr: S, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: Hard;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(0.9);
		}
	}
}



if animElem = 5 {
	sprPriority{value: 2}
}

#Change to stand state when done
call EndState(0);

#===============================================================================
# Close Standing Strong Punch
#===============================================================================
[StateDef 215;
type: S; movetype: A; physics: S;
 poweradd: 30; ctrl: 0;
 anim: 420;
sprpriority: -1;]

if animElemTime(2) >= 0 && animElemTime(7) < 0 {
	width{value: 15, 0}
}

if time > 0{
call JumpCancel();
}

if time = 0{
	call AttackLevel3();
	call Init5B();
	mapSet{map: "attackSoundGroup"; value: 5}
	mapSet{map: "attackSoundIndex"; value: 5}
	mapSet{map: "guardSoundGroup"; value: 6}
	mapSet{map: "guardSoundIndex"; value: 5}
}

if time = 2 {
	#It is worth mentioning that if you want to use the rest of the parameters
	#a playSnd uses, you can use it just the same as below:
	# Playsnd{value: S0, 4; channel: 1}
	call CSnd(0, 4, 1);
}

IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if animElem = 3 {
	hitDef{
		attr: S, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: Hard;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(1.0);
		}
	}
}

#Change to stand state when done
call EndState(0);

#===============================================================================
#Forward Heavy Punch
#===============================================================================
[StateDef 216;
type: S; movetype: A; physics: S;
 poweradd: 30; ctrl: 0;
 anim: 240;
sprpriority: -1;]

if animElemTime(2) >= 0 && animElemTime(7) < 0 {
	width{value: 15, 0}
}

if time = 0{
	call AttackLevel4();
	call Init5B();
	mapSet{map: "attackSoundGroup"; value: 5}
	mapSet{map: "attackSoundIndex"; value: 5}
	mapSet{map: "guardSoundGroup"; value: 6}
	mapSet{map: "guardSoundIndex"; value: 5}
	call SetAttackLaunchSpeed(-6, -4, -6, -4);
}

if time = 2 {
	#It is worth mentioning that if you want to use the rest of the parameters
	#a playSnd uses, you can use it just the same as below:
	# Playsnd{value: S0, 4; channel: 1}
	call CSnd(0, 4, 1);
}

IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if animElem = 4 {
	hitDef{
		attr: S, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: Hard;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(0.9);
		}
	}
}

#Change to stand state when done
call EndState(0);

#===============================================================================
# Standing light kick
#===============================================================================
# ZSS difficulty: easy
[StateDef 230;
type: S; movetype: A; physics: S;
 poweradd: 11; ctrl: 0;
 anim: 210;
sprpriority: 2;]


if time = 0{
	call AttackLevel0();
	call Init5C();
}

if time > 0{
call JumpCancel();
}

if time = 2 {
	call CSnd(0, 0, 1);
}

IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if animElem = 3 {
	hitDef{
		attr: S, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: Light;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: Low;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(0.8);
		}
	}
}


#Change to stand state when done
call EndState(0);

#===============================================================================
# Standing strong kick
#===============================================================================
# ZSS difficulty: easy
[StateDef 240;
type: S; movetype: A; physics: S;
 poweradd: 30; ctrl: 0;
 anim: 250;
sprpriority: 2;]

if time = 0{
	call AttackLevel4();
	call Init5D();
	mapSet{map: "groundPushbackX"; value: -2;}
	mapSet{map: "groundPushbackY"; value: -8;}
	mapSet{map: "airPushbackX"; value: -2;}
	mapSet{map: "airPushbackY"; value: -8;}
}

if time > 0{
call JumpCancel();
}

if time = 2 {
	call CSnd(0, 1, 1);
}
IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if animElem = 3 {
	hitDef{
		attr: S, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: Hard;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(0.9);
		}
	}
}


if animElem = 7 {
	posAdd{x: 12}
}

#Change to stand state when done
call EndState(0);

#===============================================================================
# Crouching light punch
#===============================================================================
[StateDef 400;
type: C; movetype: A; physics: C;
 poweradd: 8; ctrl: 0;
anim: 400; sprpriority: 2;]

if time = 0{
	call AttackLevel0();
	call Init2A();
	mapSet{map: "attackSoundGroup"; value: 5}
	mapSet{map: "attackSoundIndex"; value: 3}
	mapSet{map: "guardSoundGroup"; value: 6}
	mapSet{map: "guardSoundIndex"; value: 3}
}

if time = 1 {
	call CSnd(0, 0, 1);
}

IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if animElem = 2 {
	hitDef{
		attr: C, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: Light;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: Low;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(0.8);
		}
	}
}

#Change to stand state when done
call EndState(1);

#===============================================================================
# Crouching strong punch
#===============================================================================
# ZSS difficulty: easy
# Description: This is a 2-hit move. It is done by having two HitDefs
#     triggered, one for each frame of animation that hits.
#     Notice how the first hit cannot be guarded by an opponent in the
#     air, because of the "M" in the guardflag, meaning it can only
#     be guarded "middle". The second hit has an "MA" guardflag, so
#     it can be guarded both on the ground and in the air.
[StateDef 410;
type: C; movetype: A; physics: C;
 poweradd: 25; ctrl: 0;
anim: 440; sprpriority: 2;]

if time = 0{
	call AttackLevel2();
	call Init2B();
	mapSet{map: "attackSoundGroup"; value: 5}
	mapSet{map: "attackSoundIndex"; value: 4}
	mapSet{map: "guardSoundGroup"; value: 6}
	mapSet{map: "guardSoundIndex"; value: 4}
}

IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if time = 1 {
	call CSnd(0, 1, 1);
}

#This is the first hit, triggered on the 3rd element of animation.
if animElem = 3 {
	hitDef{
		attr: C, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: Hard;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: Low;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if animElem = 7{
	velSet{x: 10; y: 0}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(0.9);
		}
	}
}


#Change to stand state when done
call EndState(1);

#===============================================================================
# Crouching light kick
#===============================================================================
# ZSS difficulty: easy
[StateDef 430;
type: C; movetype: A; physics: C;
 poweradd: 11; ctrl: 0;
anim: 410; sprpriority: 2;]

if time = 0{
	call AttackLevel0();
	call Init2C();
}

IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if time = 1 {
	call CSnd(0, 0, 1);
}

if time = 0{
	hitDef{
		attr: C, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: Light;             
		guardflag: L;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: Low;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(0.7);
		}
	}
}


#Change to stand state when done
call EndState(1);

#===============================================================================
# Crouch Strong Kick
#===============================================================================
# ZSS difficulty: easy
# Description: This move uses "Trip" for the "ground.type" parameter in
#     its hitDef. It's a special type that puts the opponent in a tripped
#     animation as he falls. Also, the hitflag parameter in the hitDef
#     is set to "MAFD". The "D" indicates that a downed opponent can be
#     hit by the attack.
[StateDef 440;
type: C; movetype: A; physics: C;
 poweradd: 35; ctrl: 0;
anim: 430; sprpriority: 2;]

if time = 1 {
	call CSnd(0, 2, 1);
}

IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if time = 0{
	call AttackLevel2();
	call Init2D();
	mapSet{map: "groundPushbackX"; value: 0;}
	mapSet{map: "groundPushbackY"; value: 0;}
	mapSet{map: "airPushbackX"; value: -2;}
	mapSet{map: "airPushbackY"; value: -4;}
}

if animElem = 3 {
	hitDef{
		attr: C, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: hard;             
		guardflag: L;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: Trip;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(0.9);
		}
	}
}


#Change to stand state when done
call EndState(1);

#===============================================================================
# Jump Light Punch
#===============================================================================
# ZSS difficulty: easy
[StateDef 600;
type: A; movetype: A; physics: A;
 poweradd: 5; ctrl: 0;
anim: 600; sprpriority: 2;]

if time > 0{
call JumpCancel();
}

if time = 0{
call AttackLevel0();
call InitjA();
mapSet{map: "attackSoundGroup"; value: 5}
	mapSet{map: "attackSoundIndex"; value: 3}
	mapSet{map: "guardSoundGroup"; value: 6}
	mapSet{map: "guardSoundIndex"; value: 3}
}

IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if time = 1 {
	call CSnd(0, 0, 1);
}

if animElem = 2 {
	hitDef{
		attr: A, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: light;             
		guardflag: H;        
		hitflag: MAF;            
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(0.8);
		}
	}
}


#This gives control back to kfm early. While this could be done better in a
#number of ways, this is a 1:1 creation of kfm from elecbyte so this change is
#left intact.
if animTime = 0{
	ctrlSet{value: 1}
}

#===============================================================================
# Jump Strong Punch
#===============================================================================
# ZSS difficulty: easy
[StateDef 610;
type: A; movetype: A; physics: A;
 poweradd: 30; ctrl: 0;
anim: 650; sprpriority: 2;]

if time > 0{
call JumpCancel();
}

if time = 0{
call AttackLevel2();
call InitjB();
mapSet{map: "attackSoundGroup"; value: 5}
	mapSet{map: "attackSoundIndex"; value: 5}
	mapSet{map: "guardSoundGroup"; value: 6}
	mapSet{map: "guardSoundIndex"; value: 5}
}
IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if time = 2 {
	call CSnd(0, 1, 1);
}

if animElem = 3 {
	hitDef{
		attr: A, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: hard;             
		guardflag: H;        
		hitflag: MAF;           
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(0.8);
		}
	}
}

if animTime = 0{
	ctrlSet{value: 1}
}


#===============================================================================
# Jump Light Kick
#===============================================================================
# ZSS difficulty: easy
[StateDef 630;
type: A; movetype: A; physics: A;
 poweradd: 10; ctrl: 0;
anim: 640; sprpriority: 2;]

if time > 0{
call JumpCancel();
}

if time = 0{
call AttackLevel0();
call InitjC();
}

if time = 1 {
	call CSnd(0, 0, 1);
}

IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if animElem = 2 {
	hitDef{
		attr: A, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: Light;             
		guardflag: H;        
		hitflag: MAF;            
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(0.8);
		}
	}
}

if animTime = 0{
	ctrlSet{value: 1}
}

#===============================================================================
# Dive Kick Light
#===============================================================================
# ZSS difficulty: easy
[StateDef 635;
type: A; movetype: A; physics: N;
 poweradd: 10; ctrl: 0;
anim: 670; sprpriority: 2;]

if time > 0{
call JumpCancel();
}

if time = 0{
call AttackLevel1();
call InitjC();
call SetAttackLaunchSpeed(-4, -7, -4, -7);
velSet{x: 0; y: 0;}
}

if time = 1 {
	call CSnd(0, 0, 1);
}

if time = 13{
velSet{x: 0; y: 12;}
}

IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if time = 0 {
	hitDef{
		attr: A, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: Light;             
		guardflag: H;        
		hitflag: MAF;            
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(0.8);
		}
	}
}

if moveContact{
	changeState{value: 637}
}


if vel y > 0 && pos y >= 0 {
	call SetAttackLandingLag(8);
}

#===============================================================================
# Dive Kick Jump
#===============================================================================
# ZSS difficulty: easy
[StateDef 637;
type: A; movetype: A; physics: A;
 poweradd: 10; ctrl: 1;
anim: 45; sprpriority: 2;]

if time = 3{
velSet{x: 6; y: -8;}
}

#===============================================================================
# Jump Strong Kick
#===============================================================================
# ZSS difficulty: easy
[StateDef 640;
type: A; movetype: A; physics: A;
 poweradd: 30; ctrl: 0;
anim: 660; sprpriority: 2;]

if time > 0{
call JumpCancel();
}

if time = 0{
call AttackLevel2();
call InitjD();
}

if time = 2 {
	call CSnd(0, 1, 1);
}

IgnoreHitPause{
	if HitPauseTime = map(hitStop) {
			EnvShake{time: map(hitStop); freq: map(screenShakeSpeed);}
	}
}

if animElem = 2 {
	hitDef{
		attr: A, NA;                 
		damage: ((map(attackDamage) * map(DamageScaling)) * enemy,map(DefenseMul)) * enemy, map(GutsScaling), map(chipDamage);               
		animtype: hard;             
		guardflag: H;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		ground.velocity: map(groundPushbackX), map(groundPushbackY);
		air.velocity: map(airPushbackX), map(airPushbackY);
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill); yaccel: map(comboGravity);
	}
}

if moveHit{
	persistent(0){
		ignoreHitPause{
			call DamageScaling(0.8);
		}
	}
}


if animTime = 0{
	ctrlSet{value: 1}
}


#===============================================================================
# Override common states (use same number to override):
#===============================================================================


#===============================================================================
# States that are always executed (use StateDef -2)
#===============================================================================
[StateDef -2]


#===============================================================================
# States that are executed when in self's state file (use StateDef -3)
#===============================================================================
[StateDef -3]
#displayToClipboard{text: "p1cp: %f p2cp: %f"; params: p2BodyDist X,map(jug)}

#Landing Sound
#This controller plays a sound every time KFM lands from a jump, or back-dash.
#The code below is another way to represent the structure of
#triggerall, trigger1, trigger2
if time = 1 && (stateNo = 52 || stateNo = 106) { #Jump land || Run-back land
	call CSnd(40, 0, 1);
}
